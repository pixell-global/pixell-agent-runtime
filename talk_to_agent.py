#!/usr/bin/env python3
"""Interactive client to talk to deployed agents via A2A (gRPC)."""

import asyncio
import json
import sys
from typing import Optional

import grpc
import structlog

from pixell_runtime.proto import agent_pb2, agent_pb2_grpc

logger = structlog.get_logger()


class AgentClient:
    """Client for communicating with agents via A2A (gRPC)."""

    def __init__(self, host: str = "par.pixell.global", port: int = 443, agent_app_id: str = None):
        """Initialize the agent client.

        Args:
            host: Hostname of the PAR instance
            port: Port for gRPC (443 for HTTPS/TLS)
            agent_app_id: The agent app ID for path-based routing
        """
        self.host = host
        self.port = port
        self.agent_app_id = agent_app_id

        # Use TLS for production (par.pixell.global uses HTTPS)
        if port == 443:
            # Create SSL credentials for TLS
            self.credentials = grpc.ssl_channel_credentials()
            # For ALB routing, we need to set the correct :path header
            # gRPC uses the service name in the path, so we'll use metadata to pass the agent ID
            self.channel = grpc.aio.secure_channel(
                f"{host}:{port}",
                self.credentials,
                options=[
                    ('grpc.ssl_target_name_override', host),
                    # Set the :authority pseudo-header for HTTP/2
                    ('grpc.default_authority', host),
                ]
            )
        else:
            # Insecure for local testing (direct to container)
            self.channel = grpc.aio.insecure_channel(f"{host}:{port}")

        self.stub = agent_pb2_grpc.AgentServiceStub(self.channel)

        # Store metadata for ALB routing
        # Note: gRPC method calls will be like /pixell.agent.AgentService/Health
        # But ALB expects /agents/{agent_id}/a2a/*
        # This won't work through ALB without a proxy that rewrites paths
        self.metadata = []
        if agent_app_id:
            self.metadata.append(('x-agent-id', agent_app_id))

    async def check_health(self) -> dict:
        """Check if the agent is healthy.

        Returns:
            Health status dictionary
        """
        try:
            response = await self.stub.Health(agent_pb2.Empty())
            return {
                "ok": response.ok,
                "message": response.message,
                "timestamp": response.timestamp
            }
        except grpc.RpcError as e:
            logger.error("Health check failed", error=str(e), code=e.code())
            raise

    async def describe_capabilities(self) -> dict:
        """Get agent capabilities.

        Returns:
            Capabilities dictionary with methods and metadata
        """
        try:
            response = await self.stub.DescribeCapabilities(agent_pb2.Empty())
            return {
                "methods": list(response.methods),
                "metadata": dict(response.metadata)
            }
        except grpc.RpcError as e:
            logger.error("Failed to describe capabilities", error=str(e), code=e.code())
            raise

    async def invoke(
        self,
        action: str,
        parameters: dict
    ) -> dict:
        """Invoke an action on the agent.

        Args:
            action: The action name (e.g., "chat", "comment")
            parameters: Parameters for the action

        Returns:
            Response from the agent
        """
        # Convert parameters to string dict (protobuf limitation)
        str_params = {k: json.dumps(v) if not isinstance(v, str) else v
                      for k, v in parameters.items()}

        request = agent_pb2.ActionRequest(
            action=action,
            parameters=str_params,
            request_id=""  # Will be generated by agent if empty
        )

        logger.info("Invoking agent via A2A",
                   action=action,
                   parameters=list(parameters.keys()))

        try:
            response = await self.stub.Invoke(request)

            result = {
                "success": response.success,
                "result": response.result,
                "error": response.error if response.error else None,
                "request_id": response.request_id,
                "duration_ms": response.duration_ms
            }

            logger.info("Agent responded",
                       success=result["success"],
                       duration_ms=result.get("duration_ms"))

            return result
        except grpc.RpcError as e:
            logger.error("Invocation failed", error=str(e), code=e.code())
            raise

    async def ping(self) -> dict:
        """Ping the agent to check connectivity.

        Returns:
            Pong response with message and timestamp
        """
        try:
            response = await self.stub.Ping(agent_pb2.Empty())
            return {
                "message": response.message,
                "timestamp": response.timestamp
            }
        except grpc.RpcError as e:
            logger.error("Ping failed", error=str(e), code=e.code())
            raise

    async def close(self):
        """Close the gRPC channel."""
        await self.channel.close()


async def interactive_mode(client: AgentClient, agent_app_id: str):
    """Run interactive mode to chat with the agent.

    Args:
        client: The agent client
        agent_app_id: The agent app ID to talk to
    """
    print(f"\nü§ñ Connected to agent: {agent_app_id}")
    print("=" * 60)

    # Check health
    try:
        health = await client.check_health()
        print(f"Health: {'‚úÖ OK' if health.get('ok') else '‚ùå Not OK'}")
        print(f"Message: {health.get('message', 'N/A')}")
        print(f"Timestamp: {health.get('timestamp')}")
    except Exception as e:
        print(f"‚ö†Ô∏è  Health check failed: {e}")
        print("Continuing anyway...")

    # Get capabilities
    try:
        print("\nüìã Getting agent capabilities...")
        capabilities = await client.describe_capabilities()
        print(f"Available methods: {', '.join(capabilities.get('methods', []))}")
        if capabilities.get('metadata'):
            print(f"Metadata: {capabilities['metadata']}")
    except Exception as e:
        print(f"‚ö†Ô∏è  Failed to get capabilities: {e}")

    print("\n" + "=" * 60)
    print("Chat with the AI agent (or 'quit' to exit)")
    print("")
    print("You can:")
    print("  - Ask questions: What is Python?")
    print("  - Request code comments: comment:python:def hello(): pass")
    print("  - Just chat naturally!")
    print("=" * 60 + "\n")

    while True:
        try:
            # Get input
            user_input = input("\nüí¨ You: ").strip()

            if not user_input:
                continue

            if user_input.lower() in ['quit', 'exit', 'q']:
                print("\nüëã Goodbye!")
                break

            # Determine action and parameters based on input format
            # Format: comment:language:code OR just plain text
            if user_input.startswith("comment:") and user_input.count(':') >= 2:
                # Code comment mode: comment:language:code
                parts = user_input.split(':', 2)
                action = "comment"
                language = parts[1].strip()
                code = parts[2].strip()

                if not code:
                    print("‚ö†Ô∏è  Code cannot be empty")
                    continue

                parameters = {
                    "code": code,
                    "language": language
                }
            else:
                # Plain conversation mode
                action = "chat"
                parameters = {
                    "message": user_input
                }

            # Invoke agent
            print(f"\nüîÑ Sending to agent via A2A...")
            result = await client.invoke(
                action=action,
                parameters=parameters
            )

            # Display result
            print("\n" + "=" * 60)
            if result.get('success'):
                print("‚úÖ Success!")
                print(f"\n{result.get('result', 'No response')}")
                if result.get('duration_ms'):
                    print(f"\n‚è±Ô∏è  Duration: {result['duration_ms']}ms")
            else:
                print("‚ùå Failed!")
                if result.get('error'):
                    print(f"Error: {result['error']}")
            print("=" * 60)

        except KeyboardInterrupt:
            print("\n\nüëã Goodbye!")
            break
        except grpc.RpcError as e:
            print(f"\n‚ùå gRPC Error: {e.details()}")
            print(f"Code: {e.code()}")
        except Exception as e:
            print(f"\n‚ùå Error: {e}")
            logger.exception("Invocation failed")


async def single_invocation(
    client: AgentClient,
    language: str,
    code: str
):
    """Make a single invocation to the agent.

    Args:
        client: The agent client
        language: Programming language
        code: Code to comment
    """
    print(f"\nü§ñ Invoking agent via A2A")
    print(f"Language: {language}")
    print(f"Code: {code}\n")

    result = await client.invoke(
        action="comment",
        parameters={
            "code": code,
            "language": language
        }
    )

    print("=" * 60)
    if result.get('success'):
        print("‚úÖ Success!")
        print(f"\n{result.get('result', 'No response')}")
        if result.get('duration_ms'):
            print(f"\n‚è±Ô∏è  Duration: {result['duration_ms']}ms")
    else:
        print("‚ùå Failed!")
        if result.get('error'):
            print(f"Error: {result['error']}")
    print("=" * 60)


async def main():
    """Main entry point."""
    print("ü§ñ Agent Client (A2A/gRPC)")
    print("=" * 60)

    # Prompt for agent app ID with default
    default_agent_app_id = "4906eeb7-9959-414e-84c6-f2445822ebe4"
    agent_app_id = input(f"Enter agent app ID [{default_agent_app_id}]: ").strip()

    if not agent_app_id:
        agent_app_id = default_agent_app_id
        print(f"Using default: {agent_app_id}")

    # Use par.pixell.global with TLS on port 443
    # The ALB will route to the agent based on the :path header in HTTP/2
    host = "par.pixell.global"
    port = 443

    print(f"\nüîó Connecting to {host}:{port}")
    print(f"üìç Agent path: /agents/{agent_app_id}/a2a")

    # Note: gRPC over HTTP/2 through ALB requires the :path header
    # We'll use metadata to set the path for ALB routing

    client = AgentClient(host=host, port=port, agent_app_id=agent_app_id)

    try:
        # Always run interactive mode
        await interactive_mode(client, agent_app_id)
    finally:
        await client.close()


if __name__ == "__main__":
    asyncio.run(main())
